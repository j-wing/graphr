{"version":3,"sources":["js/es6/graph.js"],"names":[],"mappings":"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","file":"js/es6/graph.js","sourcesContent":["import {Node} from \"dist/node\";\nimport {Edge} from \"dist/edge\";\nimport * as algos from \"dist/algorithms/algorithms\";\n\nvar MAX_WEIGHT = 5;\nvar maxRandomEdgesPercent = .25\nexport class Graph {\n    constructor(ctx, bounds, directed=true, allowNegativeEdges=false) {\n        window.graph = this;\n    \tthis.ctx = ctx\n        this.vertices = [];\n        this.edges = new Map();\n        this.directed = directed;\n\n        this.startNode = null;\n        this.rendered = false;\n\n        // Disables graph modification during algorithm execution\n        this.executingAlgorithm = false;\n        this.selectedNode = null;\n        this.selectedEdge = null;\n\n        this.allowNegativeEdges = allowNegativeEdges;\n\n        this.bounds = {\n        \tw: bounds[0],\n        \th: bounds[1]\n        }\n\n        this.render(this.ctx)\n\n        this.eventHandler = null\n    }\n\n    algorithmFinished() {\n        /* Called by algorithm when it finishes executing its last step. */\n        this.executingAlgorithm = null; \n        this.setSelectedNode(null);\n    }\n\n    addVertex(value, x=null, y=null) {\n        this.addNode(new Node(value, x, y));\n    }\n\n    addNode(node) {\n        if (this.executingAlgorithm) {\n            return;\n        }\n    \tthis.vertices.push(node)\n    \tthis.edges.set(node, new Set())\n    \tif (node.x != null && node.y != null) {\n        \tthis.render(this.ctx)\n        }\n\n\n        this.eventHandler.addInteractable(node)\n    }\n\n    removeVertex(value) {\n    }\n\n    addEdge(fromNode, toNode, weight) {\n        if (this.executingAlgorithm) {\n            return;\n        }\n\n    \tvar newEdge = new Edge(fromNode, toNode, weight)\n    \tif (this.hasEdge(fromNode, toNode)) {\n    \t\tvar edge = this.getEdge(fromNode, toNode)\n    \t\tedge.weight = weight\n    \t\treturn\n    \t}\n        this.edges.get(fromNode).add(new Edge(fromNode, toNode, weight));\n        if (!this.directed) {\n            // Add the reverse edge\n            this.edges.get(toNode).add(new Edge(toNode, fromNode, weight));\n        }\n        this.render(this.ctx)\n        console.log(this.numEdges())\n    }\n\n    removeEdge(edge) { }\n\n    getVertex(v) {\n    \treturn this.vertices[v]\n    }\n\n    hasEdge(u, v) {\n    \tvar edgesFromU = this.edges.get(u)\n    \tfor (var edge of edgesFromU) {\n    \t\tif (edge.toNode === v)\n    \t\t\treturn true\n    \t}\n    \treturn false\n    }\n\n    getEdge(u, v) {\n    \tvar edgesFromU = this.edges.get(u)\n    \tfor (var edge of edgesFromU) {\n    \t\tif (edge.toNode === v)\n    \t\t\treturn edge\n    \t}\n    \treturn false\n    }\n\n    /* Returns the outgoing edges from a vertex v */\n    getEdgesFrom(v) {\n    \tvar edges = this.edges.get(v).entries()\n    \tvar edgesList = []\n    \tfor (var edge of edges) {\n    \t\tedgesList.push(edge[0])\n    \t}\n    \treturn edgesList\n    }\n\n    /* Returns the edges as a list */\n    getEdges() {\n    \tvar edges = []\n    \tfor (var v of this.vertices) {\n    \t\tedges = edges.concat(this.getEdgesFrom(v))\n    \t}\n    \treturn edges\n    }\n\n    /* Returns the number of vertices */\n    numVertices() {\n    \treturn this.vertices.length\n    }\n\n    /* Returns the number of edges */\n    numEdges() {\n    \treturn this.getEdges().length\n    }\n\n    beginAlgorithm(name) {\n        /*\n            @params: string name\n            @returns: AlgorithmState object, \n                        or null if no registered algorithm with `name` exists\n        */\n\n        if (this.algorithmExecuting) {\n            this.algorithmExecuting.cancel();\n        }\n\n        var stateCls = algos.ALGORITHM_STATES[name];\n        if (!stateCls) {\n            return null;\n        }\n\n        var state = new stateCls(this);\n        if (state.requiresStartNode()) {\n            this.chooseStartNode(state);\n        }\n        if (state.requiresEndNode()) {\n            this.chooseEndNode(state);\n        }\n\n        this.executingAlgorithm = state;\n        return state;\n    }\n\n    chooseStartNode(state) {\n        console.error(\"Implement a way to choose a start node!\");\n        state.setStartNode(this.vertices[0]);\n    }\n\n    chooseEndNode(state) {\n        console.error(\"Implement a way to choose an end node!\");\n        state.setEndNode(this.vertices.slice(-1)[0]);\n    }\n\n    setSelectedNode(node) {\n        if (this.selectedNode) {\n            this.selectedNode.setSelected(false);\n        }\n        this.selectedNode = node;\n\n        if (node) {\n            this.selectedNode.setSelected(true);\n        }\n    }\n\n    setSelectedEdge(edge) {\n        if (this.selectedEdge) {\n            this.selectedEdge.setSelected(false);\n        }\n        this.selectedEdge = edge;\n        this.selectedEdge.setSelected(true);\n    }\n\n    /* Sets up the position of the graph */\n    setUpGraph() {\n    \t// Pick a random start node\n        if (!this.startNode) {\n            this.startNode = this.vertices[0];\n        }\n\n        this.startNode.coords = [this.bounds.w / 2, this.bounds.h / 2]\n\n        this.startNode.setAngle(0)\n        // this.startNode.render(ctx)\n        var queue = [this.startNode]\n        var visited = new Set()\n\n        // Let DIST be the distance new nodes should be drawn\n        let DIST = 100\n\n        // If not rendered, render the graph\n        while (queue.length != 0) {\n        \tvar currNode = queue.shift()\n        \tvisited.add(currNode)\n\n        \tvar edgesFrom = this.getEdgesFrom(currNode)\n        \tfor (var edge of edgesFrom) {\n        \t\tif (visited.has(edge.toNode)) {\n        \t\t\tcontinue\n        \t\t}\n\n        \t\tqueue.push(edge.toNode)\n        \t\t// Set the edge coords to be distance DIST away,\n        \t\t// at a random angle b/w 0 and 2PI\n        \t\t// NEW: constrain angle based on (Message Eric if confused)\n        \t\tvar startAngle = currNode.getAngle() - (Math.PI / 2)\n        \t\tvar angle = startAngle + Math.random() * (Math.PI)\n        \t\tif (currNode === this.startNode) {\n        \t\t\t// we want edges from the first node to branch out all over\n        \t\t\tangle = Math.random() * (2*Math.PI)\n        \t\t}\n        \t\tedge.toNode.coords = [\n        \t\t\tcurrNode.x + DIST * Math.cos(angle),\n        \t\t\tcurrNode.y + DIST * Math.sin(angle)\n        \t\t]\n        \t\t// TODO: check that toNode's coords don't overlap with prev coords\n        \t\tedge.toNode.setAngle(angle)\n        \t}\n        }\n\n        this.rendered = true;\n    }\n\n    /* TODO: Need to handle updating the graph when a new node/edge is added */\n    render(ctx) {\n        // if (this.rendered) {\n\n        this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n        this.ctx.fillStyle = \"lightblue\";\n        this.ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);\n\n    \t// Render all edges first\n    \tfor (var edge of this.getEdges()) {\n    \t\tedge.render(ctx);\n    \t}\n        ctx.stroke();\n    \tfor (var node of this.vertices) {\n    \t\t// console.log(this.vertices.length)\n    \t\tnode.render(ctx);\n    \t}\n        //} else {\n        //\tthis.setUpGraph()\n        //}\n    }\n\n\n\n    static simpleGraph(numVertices=2, directed=true, defaultValue=5) {\n        var graph = new Graph(directed);\n        for (var i=0; i < numVertices;i++) {\n            graph.addVertex(defaultValue);\n            if (i != 0) {\n                graph.addEdge(graph.vertices[i-1], graph.vertices[i], 1);\n            }\n        }\n        return graph;\n    }\n\n    static randomGraph(ctx, numVertices=10, directed=true) {\n        var graph = new Graph(ctx, directed);\n        for (var i = 1; i <= numVertices; i++) {\n            graph.addVertex(i);\n        }\n\n        for (var i = 0; i < numVertices; i++) {\n            // Pick a random node to connect to\n            for (var edgeCount=0;edgeCount < _.random(Math.ceil(maxRandomEdgesPercent*numVertices)); edgeCount++) {\n                var other = _.sample(graph.vertices);\n                if (other == graph.vertices[i]) {\n                    continue;\n                }\n\n                // Assign a random weight\n                var weight;\n                if (graph.allowNegativeEdges) {\n                    weight = _.random(-MAX_WEIGHT, MAX_WEIGHT+1);\n                }\n                else {\n                    weight = _.random(MAX_WEIGHT+1);\n                }\n                graph.addEdge(graph.vertices[i], other, weight);\n            }\n        }\n        return graph;\n    }\n}\n"]}