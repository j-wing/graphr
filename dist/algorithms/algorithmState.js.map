{"version":3,"sources":["js/es6/algorithms/algorithmState.js"],"names":[],"mappings":";;;MAAa,cAAc;QAAd,cAAc,GACZ,SADF,cAAc,CACX,KAAK,EAAE;AACf,UAAI,CAAC,KAAK,GAAG,KAAK,CAAC;AACnB,UAAI,CAAC,UAAU,GAAG,KAAK,CAAC;AACxB,UAAI,CAAC,SAAS,GAAG,IAAI,CAAC;AACtB,UAAI,CAAC,OAAO,GAAG,IAAI,CAAC;AACpB,UAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC;AAC1B,UAAI,CAAC,aAAa,GAAG,IAAI,CAAC;KAC7B;;AARQ,kBAAc,WAUvB,MAAM,GAAA,YAAG;AACL,UAAI,IAAI,CAAC,aAAa,EAAE;AACpB,oBAAY,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;OACpC;KACJ;;AAdQ,kBAAc,WAgBvB,iBAAiB,GAAA,YAAG;;;;;;AAMhB,aAAO,KAAK,CAAC;KAChB;;AAvBQ,kBAAc,WAyBvB,eAAe,GAAA,YAAG;;;;;;AAMd,aAAO,KAAK,CAAC;KAChB;;AAhCQ,kBAAc,WAkCvB,YAAY,GAAA,UAAC,IAAI,EAAE;;;;AAIf,UAAI,CAAC,SAAS,GAAG,IAAI,CAAC;KACzB;;AAvCQ,kBAAc,WAyCvB,UAAU,GAAA,UAAC,IAAI,EAAE;AACb,UAAI,CAAC,OAAO,GAAG,IAAI,CAAC;KACvB;;AA3CQ,kBAAc,WA6CvB,QAAQ,GAAA,YAAG;AACP,UAAI,CAAC,IAAI,CAAC,UAAU,EAAE;AAClB,YAAI,CAAC,IAAI,EAAE,CAAC;AACZ,YAAI,CAAC,aAAa,GAAG,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;OACpF;KAEJ;;AAnDQ,kBAAc,WAqDvB,mBAAmB,GAAA,UAAC,QAAQ,EAAE;;;;;;AAO1B,UAAI,CAAC,gBAAgB,GAAG,QAAQ,CAAC;AACjC,UAAI,QAAQ,KAAK,CAAC,EAAE;AAChB,YAAI,CAAC,aAAa,GAAG,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;OACpF;KACJ;;AAhEQ,kBAAc,WAmEvB,IAAI,GAAA,YAAG;;;;AAIH,YAAM,qBAAqB,CAAC;;;AAvEvB,kBAAc,WA0EvB,QAAQ,GAAA,YAAG;AACP,YAAM,qBAAqB,CAAC;;;WA3EvB,cAAc;;;UAAd,cAAc,GAAd,cAAc","file":"js/es6/algorithms/algorithmState.js","sourcesContent":["export class AlgorithmState {\n    constructor(graph) {\n        this.graph = graph;\n        this.isFinished = false;\n        this.startNode = null;\n        this.endNode = null;\n        this.autoStepInterval = 0;\n        this.autoStepTimer = null;\n    }\n\n    cancel() {\n        if (this.autoStepTimer) {\n            clearTimeout(this.autoStepTimer);\n        }\n    }\n\n    requiresStartNode() {\n        /*\n            Abstract method;\n            returns true if this state requires a start node to begin.\n            Defaults to false.\n        */\n        return false;\n    }\n\n    requiresEndNode() {\n        /*\n            Abstract method;\n            returns true if this state requires an end node.\n            Also defaults to false.\n        */\n        return false;\n    }\n\n    setStartNode(node) {\n        /*\n            Abstract method;\n        */\n        this.startNode = node;\n    }\n\n    setEndNode(node) {\n        this.endNode = node;\n    }\n\n    autoStep() {\n        if (!this.isFinished) {\n            this.next();\n            this.autoStepTimer = setTimeout(this.autoStep.bind(this), this.autoStepInterval);\n        }\n\n    }\n\n    setAutoStepInterval(interval) {\n        /*\n            Sets the interval at which the algorithm automatically calls .next().\n            Set to 0 to disable auto-stepping.\n\n            TODO: determine whether this should call autoStep immediately, or after a delay of `interval`\n        */\n        this.autoStepInterval = interval;\n        if (interval !== 0) {\n            this.autoStepTimer = setTimeout(this.autoStep.bind(this), this.autoStepInterval);\n        }\n    }\n\n\n    next() {\n        /*\n            Abstract method for advancing the state of the algorithm.\n        */\n        throw \"NotImplementedError\";\n    }\n\n    previous() {\n        throw \"NotImplementedError\";\n    }\n}"]}